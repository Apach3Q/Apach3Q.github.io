<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Algorithm," />










<meta name="description" content="Reference a lot of online information and summarized the various sorting algorithms, record the notes.In the study stage, if has the question welcome to correct, discusses together.@Apach3  ForewordNo">
<meta name="keywords" content="Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Sort Algorithm Summary">
<meta property="og:url" content="https://github.com/Apach3Q/Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/index.html">
<meta property="og:site_name" content="Apach3&#39;s Blog">
<meta property="og:description" content="Reference a lot of online information and summarized the various sorting algorithms, record the notes.In the study stage, if has the question welcome to correct, discusses together.@Apach3  ForewordNo">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://github.com/img/Insertion-Sort.gif">
<meta property="og:image" content="https://github.com/img/Shell-Sort.gif">
<meta property="og:image" content="https://github.com/img/Shell-Sort1.svg">
<meta property="og:image" content="https://github.com/img/Shell-Sort2.svg">
<meta property="og:image" content="https://github.com/img/Shell-Sort1.svg">
<meta property="og:image" content="https://github.com/img/Shell-Sort2.svg">
<meta property="og:image" content="https://github.com/img/Selection-Sort.gif">
<meta property="og:image" content="https://github.com/img/Heap-sort.gif">
<meta property="og:updated_time" content="2017-11-16T07:02:03.874Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sort Algorithm Summary">
<meta name="twitter:description" content="Reference a lot of online information and summarized the various sorting algorithms, record the notes.In the study stage, if has the question welcome to correct, discusses together.@Apach3  ForewordNo">
<meta name="twitter:image" content="https://github.com/img/Insertion-Sort.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/Apach3Q/Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/"/>





  <title>Sort Algorithm Summary | Apach3's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Apach3's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Emmmmmmm...Welcome to my blog, LOL ~ ~ ~ :)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/Apach3Q/Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Apach3">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apach3's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Sort Algorithm Summary</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-15T09:40:40+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/15/Sort-Algorithm-Summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/15/Sort-Algorithm-Summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>Reference a lot of online information and summarized the various sorting algorithms, record the notes.</strong><br><strong>In the study stage, if has the question welcome to correct, discusses together.<a href="https://apach3q.github.io/" target="_blank" rel="external">@Apach3</a></strong></p>
<hr>
<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>Nowadays, data is everywhere and sorting the data is the first step.There are eight kinds of commonly used sorting algorithms: Insertion  Sort、Shell Sort、Selection Sort、Heap Sort、Bubble Sort、Quick Sort、Merge Sort and Radix Sort.Next I will summarize each sorting algorithm.</p>
<a id="more"></a>
<p>现如今，数据无处不在，整理数据的第一步就是排序。常用的八种排序算法有：插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序、归并排序和基数排序。下面我将依次总结各个排序算法。</p>
<hr>
<h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p><strong>Overview:</strong></p>
<p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
<p><strong>概述：</strong></p>
<p>循环插入排序，每次重复使用一个输入元素，并增长排序后的输出列表。在每次循环中，插入排序从输入数据中移除一个元素，找到它在排序列表中的位置，将它插入到那里。重复此操作直到没有输入元素。</p>
<p><img src="/img/Insertion-Sort.gif" alt="Insertion Sort"></p>
<p><strong>Insertion Sort Code In C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void insertion_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 1, j = 0 ; i &lt; len; ++i) &#123;    //compare (len - 1) times, until the last number left</span><br><span class="line">        int temp = arr[i];  //temp is the key number</span><br><span class="line">        for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; --j)   //compare all numbers before the key number</span><br><span class="line">            arr[j + 1] = arr[j];    //find the value lager than the key number and insert it behind the key</span><br><span class="line">        arr[j + 1] = temp;     //insert the key number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Best, Worst, And Average Cases:</strong></p>
<p>The best case input is an array that is already sorted. In this case insertion sort has a linear running time (i.e., O(n)). During each iteration, the first remaining element of the input is only compared with the right-most element of the sorted subsection of the array.<br>The simplest worst case input is an array sorted in reverse order. The set of all worst case inputs consists of all arrays where each element is the smallest or second-smallest of the elements before it. In these cases every iteration of the inner loop will scan and shift the entire sorted subsection of the array before inserting the next element. This gives insertion sort a quadratic running time (i.e., O(n2)).<br>The average case is also quadratic, which makes insertion sort impractical for sorting large arrays. However, insertion sort is one of the fastest algorithms for sorting very small arrays, even faster than quicksort; indeed, good quicksort implementations use insertion sort for arrays smaller than a certain threshold, also when arising as subproblems; the exact threshold must be determined experimentally and depends on the machine, but is commonly around ten.</p>
<p><strong>最佳，最差和平均情况：</strong></p>
<p>最好的情况下就是数组已经是排好了序的。这种情况下插入排序具有线性运行时间（即时间复杂度O(n)）。每次迭代期间输入的第一个元素仅与排序数组的最右侧元素进行比较。<br>最简单的最坏情况是倒序排序的数组。每个元素是其之前元素的最小或次最小值。在这种情况下每次循环都会扫描并且移动这个数组整个排序的子部分。这种情况下的排序时间复杂度为二次的（即O(n^2)）。<br>平均情况下的时间复杂度也是二次的，这使得插入排序在排列大型数组的情况下是不切实际的。然而插入排序是排序非常小的数组最快的算法之一，甚至速度大过快速排序；实际上，好的快速排序对于小于某个阈值的数组的时候会使用插入排序，同样作为一个字问题出现的就是阈值必须通过实验来确定，取决于机器，但是通常在10左右。</p>
<hr>
<h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><p><strong>Overview:</strong></p>
<p>Shell sort can be seen as either a generalization of sorting by exchange (bubble sort) or sorting by insertion (insertion sort).The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements, it can move some out-of-place elements into position faster than a simple nearest neighbor exchange.The running time of Shell sort is heavily dependent on the gap sequence it uses. For many practical variants, determining their time complexity remains an open problem.</p>
<p><strong>概述：</strong></p>
<p>希尔排序可以被看作是交换排序（冒泡排序）或插入排序的泛化。该方法通过对距离较远的一对元素进行排序，然后减少要比较元素之间的差距。从相距较远的元素开始，它可以将一些不适合的元素移动到比简单临近距离交换更快的位置。希尔排序的时间复杂度很大程度取决于它的间隙距离。对于很多实际的变体，确定时间复杂度仍是一个公开的问题。</p>
<p><img src="/img/Shell-Sort.gif" alt="Shell Sort"></p>
<p><strong>Shell Sort Code In C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void ShellInsertSort(int a[], int n, int dk) &#123;</span><br><span class="line">    for(int i = dk; i &lt; n; ++i)&#123;</span><br><span class="line">        if(a[i] &lt; a[i-dk]) &#123;          //if the i-th element is greater than the i-1 element, than insert.else, insert after moving ordered list</span><br><span class="line">            int j = i - dk;</span><br><span class="line">            int x = a[i];           //store to be sorted elements</span><br><span class="line">            a[i] = a[i - dk];         //first, move one element backward</span><br><span class="line">            while(x &lt; a[j]) &#123;     //find the insertion position in the sorted list</span><br><span class="line">                a[j + dk] = a[j];</span><br><span class="line">                j -= dk;             //element backward</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + dk] = x;            //insert into the correct position</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void shellSort(int a[], int n) &#123;</span><br><span class="line">    int dk = n/2;       //Sort in increments of n/2 first</span><br><span class="line">    while( dk &gt;= 1  ) &#123;</span><br><span class="line">        ShellInsertSort(a, n, dk);</span><br><span class="line">        dk = dk/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Gap Sequence:</strong></p>
<p>The gap selection is an important part of Shell Sort. Donald Shell suggested that the gap be taken from half to 1. Although this can be better than the O(n^2) algorithm(Insertion Sort), there is a room for reducing the average time performance. The best gap sequence is proposed by Sedgewick(1, 5, 19, 41, 109, …), and this sequence is derived from the two formulas,<img src="/img/Shell-Sort1.svg" alt="Shell Sort1"> and <img src="/img/Shell-Sort2.svg" alt="Shell Sort2">. Study also shows that ‘Comparison is the most important operation not exchange in Shell Sort’. Shell Sort faster than Insertion Sort in using this gap sequence, even in small array faster than Quick Sort and Heap Sort, but on Shell Sort involves a large amount of data still slower than Quick Sort.</p>
<p><strong>步长序列：</strong></p>
<p>步长的选择是希尔排序的重要部分。Donald Shell最初建议步长取半值直到步长到1。虽然这样取可以比O(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间复杂度的余地。已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自<img src="/img/Shell-Sort1.svg" alt="Shell Sort1">和<img src="/img/Shell-Sort2.svg" alt="Shell Sort2">这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<p><strong>Time Performance:</strong></p>
<p>Worst-case performance:O(n^2) (worst known gap sequence)、O(nlog2n) (best known gap sequence)<br>Best-case performance:O(nlogn)<br>Average performance:depends on gap sequence</p>
<p><strong>时间复杂度：</strong></p>
<p>最坏时间复杂度：根据步长序列的不同而不同。已知最差的：O(n^2)、最好的：O(nlog2n)<br>最优时间复杂度：O(nlogn)<br>平均时间复杂度：根据步长序列的不同而不同。</p>
<hr>
<h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p><strong>Overview:</strong></p>
<p>Selection sort is an in-place comparison sort. It has O(n^2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.<br>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
<p><strong>概述：</strong></p>
<p>选择排序是一种就地的比较排序。它有O(n^2)的时间复杂度，使其在大型列表上效率低下，并且通常比类似的插入排序更差。选择排序因其简单性，在某些情况下，特别是在辅助存储器有限的情况下，其具有比更复杂算法的性能优势。<br>该算法将输入列表分成两部分：已经排序的项目的子列表，其从列表的前部（左侧）从左到右构建，剩余的项目的子列表占据剩余的名单。最初，排序的子列表是空的，未排序的子列表是整个输入列表。该算法通过找到未排序的子列表中的最小（或最大，取决于排序顺序）元素，与最左边的未排序元素交换（交换）它（按照排序顺序），并且将子列表边界向右移动一个元素。</p>
<p><img src="/img/Selection-Sort.gif" alt="Selection Sort"></p>
<p><strong>Selection Sort Code In C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *a,int *b) &#123;          //used to swap two integers</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void selection_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 0,min = 0 ; i &lt; len - 1; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;    //traverse unsorted elements</span><br><span class="line">            if (arr[min] &lt; arr[j]) &#123;   //find the current minimum</span><br><span class="line">                min = j;        //record the subscript value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[min], &amp;arr[i]);    //exchange the value</span><br><span class="line">    &#125;    //the end of each loop will make the beginning of the array to form an ordered sequence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p><strong>Overview:</strong></p>
<p>Heap sort can be thought of as an improved selection sort. Although somewhat slower in practice on most machines than a well-implemented quicksort, it has the advantage of a more favorable worst-case O(nlogn) runtime. Heapsort is an in-place algorithm, but it is not a stable sort.</p>
<p><strong>概述：</strong></p>
<p>堆排序被认为是改进的选择排序。尽管有时候在大多数机器上的实践比快速排序稍慢，但它具有最优的最坏情况O(nlogn)时间复杂度的特点。堆排序是一个就地算法，但是一个不稳定的排序。</p>
<p><strong>Algorithm:</strong></p>
<p>The Heap sort algorithm can be divided into two parts.<br>In the first step, a heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iParent(i) = floor((i-1) / 2) where floor functions map a real number to the smallest leading integer.</span><br><span class="line">iLeftChild(i)  = 2*i + 1</span><br><span class="line">iRightChild(i) = 2*i + 2</span><br></pre></td></tr></table></figure></p>
<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.<br>Therefore, two problems need to be solved:<br>(1) How to build a heap?<br>(2) How to adjust the remaining (n-1) elements to make it a new heap?</p>
<p>The way to build a heap:<br>A complete binary tree have n nodes, the last node is the n/2 th node of the sub-tree, filter start from n/2 th node and then fliter the nodes to the root sub-tree, make each to be a heap until the root node.</p>
<p>The way to adjust and build a new heap:<br>Outputs the top element of the heap, moving the heap bottom element to the location of the original heap top element. Decide it if a heap, by building heap method, adjust to a heap.</p>
<p>As show below:</p>
<p><img src="/img/Heap-sort.gif" alt="Heap Sort"></p>
<p><strong>算法：</strong></p>
<p>堆排序算法可以分为两部分。<br>在第一步中，一个堆是建立在数据之外的。堆常常放在一个完整的二叉树布局的数组中。完整的二叉树将二叉树结构映射到数组索引; 每个数组索引代表一个节点; 节点的父节点，左节点子节点或右节点子节点的索引是简单表达式。对于从零开始的数组，根节点存储在索引0; 如果i是当前节点的索引，那么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iParent（i）= floor（（i-1）/ 2）其中floor函数将实数映射到最小的前导整数。</span><br><span class="line">iLeftChild（i）= 2 * i + 1</span><br><span class="line">iRightChild（i）= 2 * i + 2</span><br></pre></td></tr></table></figure></p>
<p>在第二步中，通过反复从堆（堆的根）中删除最大的元素，并将其插入到数组中，创建一个有序的数组。每次移除堆后都会更新堆以维护堆属性。一旦所有对象都从堆中移除，结果是一个有序的数组。<br>因此需要解决两个问题：<br>（1） 如何建堆？<br>（2） 如何调整剩余（n-1）个元素使其成为一个新堆？</p>
<p>建堆的方法：<br>n个结点的完全二叉树，最后一个结点是第n / 2个个结点的子树，筛选从n / 2个结点开始，依次向前对各结点为根对子树进行筛选，使之成为堆，直到根结点。</p>
<p>调整构建新堆的办法：<br>输出堆的顶部元素，将堆底部元素移动到原始堆顶部元素的位置。判断是否为堆，通过生成堆方法，调整为堆。</p>
<p>如上图所示。</p>
<p><strong>Heap sort code in C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void swap(int* a, int* b) &#123;</span><br><span class="line">    int temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void max_heapify(int arr[], int start, int end) &#123;</span><br><span class="line">    //set up parent and sub-node index</span><br><span class="line">    int dad = start;</span><br><span class="line">    int son = dad * 2 + 1;</span><br><span class="line">    while (son &lt;= end) &#123;                //compared if sub-node index in range</span><br><span class="line">        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //compare two nodes, select the significant</span><br><span class="line">            son++;</span><br><span class="line">        if (arr[dad] &gt; arr[son]) //adjustment finished when parent node larger than sub-node, then jump out of the function</span><br><span class="line">            return;</span><br><span class="line">        else &#123;              //else exchange parent node and sub-node, then sub-node compared with sub-sub-node</span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    //init, i start with the last parent node</span><br><span class="line">    for (i = len / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        max_heapify(arr, i, len - 1);</span><br><span class="line">        //swap the first element with the previous one, and then adjust it until the end</span><br><span class="line">    for (i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(&amp;arr[0], &amp;arr[i]);</span><br><span class="line">        max_heapify(arr, 0, i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><hr>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><hr>
<h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><hr>
<h2 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h2><hr>
<p>未完待续！</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/13/The-Differences-between-TCP-UDP-HTTP-HTTPS-GET-POST/" rel="next" title="The Differences between TCP&UDP/HTTP&HTTPS/GET&POST">
                <i class="fa fa-chevron-left"></i> The Differences between TCP&UDP/HTTP&HTTPS/GET&POST
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.png"
                alt="Apach3" />
            
              <p class="site-author-name" itemprop="name">Apach3</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry, stay foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Foreword"><span class="nav-number">1.</span> <span class="nav-text">Foreword</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Insertion-Sort"><span class="nav-number">2.</span> <span class="nav-text">Insertion Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-Sort"><span class="nav-number">3.</span> <span class="nav-text">Shell Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selection-Sort"><span class="nav-number">4.</span> <span class="nav-text">Selection Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Sort"><span class="nav-number">5.</span> <span class="nav-text">Heap Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bubble-Sort"><span class="nav-number">6.</span> <span class="nav-text">Bubble Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">7.</span> <span class="nav-text">Quick Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Merge-Sort"><span class="nav-number">8.</span> <span class="nav-text">Merge Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Radix-Sort"><span class="nav-number">9.</span> <span class="nav-text">Radix Sort</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Apach3</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://github.com/Apach3Q/Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/';
          this.page.identifier = '2017/11/15/Sort-Algorithm-Summary/';
          this.page.title = 'Sort Algorithm Summary';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  








  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
