<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Algorithm," />










<meta name="description" content="Reference a lot of online information and summarized the various sorting algorithms, record the notes.In the study stage, if has the question welcome to correct, discusses together.@Apach3  ForewordNo">
<meta name="keywords" content="Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Sort Algorithm Summary">
<meta property="og:url" content="https://Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/index.html">
<meta property="og:site_name" content="Apach3&#39;s Blog">
<meta property="og:description" content="Reference a lot of online information and summarized the various sorting algorithms, record the notes.In the study stage, if has the question welcome to correct, discusses together.@Apach3  ForewordNo">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://apach3q.github.io.git/img/Insertion-Sort.gif">
<meta property="og:image" content="https://apach3q.github.io.git/img/Shell-Sort.gif">
<meta property="og:image" content="https://apach3q.github.io.git/img/Shell-Sort1.svg">
<meta property="og:image" content="https://apach3q.github.io.git/img/Shell-Sort2.svg">
<meta property="og:image" content="https://apach3q.github.io.git/img/Shell-Sort1.svg">
<meta property="og:image" content="https://apach3q.github.io.git/img/Shell-Sort2.svg">
<meta property="og:image" content="https://apach3q.github.io.git/img/Selection-Sort.gif">
<meta property="og:image" content="https://apach3q.github.io.git/img/Heap-Sort.gif">
<meta property="og:image" content="https://apach3q.github.io.git/img/Bubble-Sort.gif">
<meta property="og:image" content="https://apach3q.github.io.git/img/Merge-Sort.gif">
<meta property="og:image" content="https://apach3q.github.io.git/img/Summarize-1.png">
<meta property="og:image" content="https://apach3q.github.io.git/img/Summarize-2.png">
<meta property="og:updated_time" content="2017-11-17T09:21:09.842Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sort Algorithm Summary">
<meta name="twitter:description" content="Reference a lot of online information and summarized the various sorting algorithms, record the notes.In the study stage, if has the question welcome to correct, discusses together.@Apach3  ForewordNo">
<meta name="twitter:image" content="https://apach3q.github.io.git/img/Insertion-Sort.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/"/>





  <title>Sort Algorithm Summary | Apach3's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Apach3's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Emmmmmmm...Welcome to my blog, LOL ~ ~ ~ :)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Apach3">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/icon.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Apach3's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Sort Algorithm Summary</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-15T09:40:40+08:00">
                2017-11-15
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/15/Sort-Algorithm-Summary/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/11/15/Sort-Algorithm-Summary/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/11/15/Sort-Algorithm-Summary/" class="leancloud_visitors" data-flag-title="Sort Algorithm Summary">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>Reference a lot of online information and summarized the various sorting algorithms, record the notes.</strong><br><strong>In the study stage, if has the question welcome to correct, discusses together.<a href="https://apach3q.github.io/" target="_blank" rel="external">@Apach3</a></strong></p>
<hr>
<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><p>Nowadays, data is everywhere and sorting the data is the first step.There are eight kinds of commonly used sorting algorithms: Insertion  Sort、Shell Sort、Selection Sort、Heap Sort、Bubble Sort、Quick Sort and Merge Sort.Next I will summarize each sorting algorithm.</p>
<a id="more"></a>
<p>现如今，数据无处不在，整理数据的第一步就是排序。常用的八种排序算法有：插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序和归并排序。下面我将依次总结各个排序算法。</p>
<hr>
<h2 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h2><p><strong>Overview:</strong></p>
<p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
<p><strong>概述：</strong></p>
<p>循环插入排序，每次重复使用一个输入元素，并增长排序后的输出列表。在每次循环中，插入排序从输入数据中移除一个元素，找到它在排序列表中的位置，将它插入到那里。重复此操作直到没有输入元素。</p>
<p><img src="/img/Insertion-Sort.gif" alt="Insertion Sort"></p>
<p><strong>Insertion Sort Code In C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void insertion_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 1, j = 0 ; i &lt; len; ++i) &#123;    //compare (len - 1) times, until the last number left</span><br><span class="line">        int temp = arr[i];  //temp is the key number</span><br><span class="line">        for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; --j)   //compare all numbers before the key number</span><br><span class="line">            arr[j + 1] = arr[j];    //find the value lager than the key number and insert it behind the key</span><br><span class="line">        arr[j + 1] = temp;     //insert the key number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Best, Worst, And Average Cases:</strong></p>
<p>The best case input is an array that is already sorted. In this case insertion sort has a linear running time (i.e., O(n)). During each iteration, the first remaining element of the input is only compared with the right-most element of the sorted subsection of the array.<br>The simplest worst case input is an array sorted in reverse order. The set of all worst case inputs consists of all arrays where each element is the smallest or second-smallest of the elements before it. In these cases every iteration of the inner loop will scan and shift the entire sorted subsection of the array before inserting the next element. This gives insertion sort a quadratic running time (i.e., O(n2)).<br>The average case is also quadratic, which makes insertion sort impractical for sorting large arrays. However, insertion sort is one of the fastest algorithms for sorting very small arrays, even faster than quicksort; indeed, good quicksort implementations use insertion sort for arrays smaller than a certain threshold, also when arising as subproblems; the exact threshold must be determined experimentally and depends on the machine, but is commonly around ten.</p>
<p><strong>最佳，最差和平均情况：</strong></p>
<p>最好的情况下就是数组已经是排好了序的。这种情况下插入排序具有线性运行时间（即时间复杂度O(n)）。每次迭代期间输入的第一个元素仅与排序数组的最右侧元素进行比较。<br>最简单的最坏情况是倒序排序的数组。每个元素是其之前元素的最小或次最小值。在这种情况下每次循环都会扫描并且移动这个数组整个排序的子部分。这种情况下的排序时间复杂度为二次的（即O(n^2)）。<br>平均情况下的时间复杂度也是二次的，这使得插入排序在排列大型数组的情况下是不切实际的。然而插入排序是排序非常小的数组最快的算法之一，甚至速度大过快速排序；实际上，好的快速排序对于小于某个阈值的数组的时候会使用插入排序，同样作为一个字问题出现的就是阈值必须通过实验来确定，取决于机器，但是通常在10左右。</p>
<hr>
<h2 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h2><p><strong>Overview:</strong></p>
<p>Shell sort can be seen as either a generalization of sorting by exchange (bubble sort) or sorting by insertion (insertion sort).The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. Starting with far apart elements, it can move some out-of-place elements into position faster than a simple nearest neighbor exchange.The running time of Shell sort is heavily dependent on the gap sequence it uses. For many practical variants, determining their time complexity remains an open problem.</p>
<p><strong>概述：</strong></p>
<p>希尔排序可以被看作是交换排序（冒泡排序）或插入排序的泛化。该方法通过对距离较远的一对元素进行排序，然后减少要比较元素之间的差距。从相距较远的元素开始，它可以将一些不适合的元素移动到比简单临近距离交换更快的位置。希尔排序的时间复杂度很大程度取决于它的间隙距离。对于很多实际的变体，确定时间复杂度仍是一个公开的问题。</p>
<p><img src="/img/Shell-Sort.gif" alt="Shell Sort"></p>
<p><strong>Shell Sort Code In C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void ShellInsertSort(int a[], int n, int dk) &#123;</span><br><span class="line">    for(int i = dk; i &lt; n; ++i)&#123;</span><br><span class="line">        if(a[i] &lt; a[i-dk]) &#123;          //if the i-th element is greater than the i-1 element, than insert.else, insert after moving ordered list</span><br><span class="line">            int j = i - dk;</span><br><span class="line">            int x = a[i];           //store to be sorted elements</span><br><span class="line">            a[i] = a[i - dk];         //first, move one element backward</span><br><span class="line">            while(x &lt; a[j]) &#123;     //find the insertion position in the sorted list</span><br><span class="line">                a[j + dk] = a[j];</span><br><span class="line">                j -= dk;             //element backward</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + dk] = x;            //insert into the correct position</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void shell_sort(int a[], int n) &#123;</span><br><span class="line">    int dk = n/2;       //Sort in increments of n/2 first</span><br><span class="line">    while( dk &gt;= 1  ) &#123;</span><br><span class="line">        ShellInsertSort(a, n, dk);</span><br><span class="line">        dk = dk/2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Gap Sequence:</strong></p>
<p>The gap selection is an important part of Shell Sort. Donald Shell suggested that the gap be taken from half to 1. Although this can be better than the O(n^2) algorithm(Insertion Sort), there is a room for reducing the average time performance. The best gap sequence is proposed by Sedgewick(1, 5, 19, 41, 109, …), and this sequence is derived from the two formulas,<img src="/img/Shell-Sort1.svg" alt="Shell Sort1"> and <img src="/img/Shell-Sort2.svg" alt="Shell Sort2">. Study also shows that ‘Comparison is the most important operation not exchange in Shell Sort’. Shell Sort faster than Insertion Sort in using this gap sequence, even in small array faster than Quick Sort and Heap Sort, but on Shell Sort involves a large amount of data still slower than Quick Sort.</p>
<p><strong>步长序列：</strong></p>
<p>步长的选择是希尔排序的重要部分。Donald Shell最初建议步长取半值直到步长到1。虽然这样取可以比O(n^2)类的算法（插入排序）更好，但这样仍然有减少平均时间复杂度的余地。已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自<img src="/img/Shell-Sort1.svg" alt="Shell Sort1">和<img src="/img/Shell-Sort2.svg" alt="Shell Sort2">这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<p><strong>Time Performance:</strong></p>
<p>Worst-case performance:O(n^2) (worst known gap sequence)、O(nlog2n) (best known gap sequence)<br>Best-case performance:O(nlogn)<br>Average performance:depends on gap sequence</p>
<p><strong>时间复杂度：</strong></p>
<p>最坏时间复杂度：根据步长序列的不同而不同。已知最差的：O(n^2)、最好的：O(nlog2n)<br>最优时间复杂度：O(nlogn)<br>平均时间复杂度：根据步长序列的不同而不同。</p>
<hr>
<h2 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h2><p><strong>Overview:</strong></p>
<p>Selection sort is an in-place comparison sort. It has O(n^2) time complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where auxiliary memory is limited.<br>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
<p><strong>概述：</strong></p>
<p>选择排序是一种就地的比较排序。它有O(n^2)的时间复杂度，使其在大型列表上效率低下，并且通常比类似的插入排序更差。选择排序因其简单性，在某些情况下，特别是在辅助存储器有限的情况下，其具有比更复杂算法的性能优势。<br>该算法将输入列表分成两部分：已经排序的项目的子列表，其从列表的前部（左侧）从左到右构建，剩余的项目的子列表占据剩余的名单。最初，排序的子列表是空的，未排序的子列表是整个输入列表。该算法通过找到未排序的子列表中的最小（或最大，取决于排序顺序）元素，与最左边的未排序元素交换（交换）它（按照排序顺序），并且将子列表边界向右移动一个元素。</p>
<p><img src="/img/Selection-Sort.gif" alt="Selection Sort"></p>
<p><strong>Selection Sort Code In C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void swap(int *a,int *b) &#123;          //used to swap two integers</span><br><span class="line">    int temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void selection_sort(int arr[], int len) &#123;</span><br><span class="line">    for (int i = 0,min = 0 ; i &lt; len - 1; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        for (int j = i + 1; j &lt; len; j++) &#123;    //traverse unsorted elements</span><br><span class="line">            if (arr[min] &lt; arr[j]) &#123;   //find the current minimum</span><br><span class="line">                min = j;        //record the subscript value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[min], &amp;arr[i]);    //exchange the value</span><br><span class="line">    &#125;    //the end of each loop will make the beginning of the array to form an ordered sequence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h2><p><strong>Overview:</strong></p>
<p>Heap sort can be thought of as an improved selection sort. Although somewhat slower in practice on most machines than a well-implemented quicksort, it has the advantage of a more favorable worst-case O(nlogn) runtime. Heapsort is an in-place algorithm, but it is not a stable sort.</p>
<p><strong>概述：</strong></p>
<p>堆排序被认为是改进的选择排序。尽管有时候在大多数机器上的实践比快速排序稍慢，但它具有最优的最坏情况O(nlogn)时间复杂度的特点。堆排序是一个就地算法，但是一个不稳定的排序。</p>
<p><strong>Algorithm:</strong></p>
<p>The Heap sort algorithm can be divided into two parts.<br>In the first step, a heap is built out of the data. The heap is often placed in an array with the layout of a complete binary tree. The complete binary tree maps the binary tree structure into the array indices; each array index represents a node; the index of the node’s parent, left child branch, or right child branch are simple expressions. For a zero-based array, the root node is stored at index 0; if i is the index of the current node, then<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iParent(i) = floor((i-1) / 2) where floor functions map a real number to the smallest leading integer.</span><br><span class="line">iLeftChild(i)  = 2*i + 1</span><br><span class="line">iRightChild(i) = 2*i + 2</span><br></pre></td></tr></table></figure></p>
<p>In the second step, a sorted array is created by repeatedly removing the largest element from the heap (the root of the heap), and inserting it into the array. The heap is updated after each removal to maintain the heap property. Once all objects have been removed from the heap, the result is a sorted array.<br>Therefore, two problems need to be solved:<br>(1) How to build a heap?<br>(2) How to adjust the remaining (n-1) elements to make it a new heap?</p>
<p>The way to build a heap:<br>A complete binary tree have n nodes, the last node is the n/2 th node of the sub-tree, filter start from n/2 th node and then fliter the nodes to the root sub-tree, make each to be a heap until the root node.</p>
<p>The way to adjust and build a new heap:<br>Outputs the top element of the heap, moving the heap bottom element to the location of the original heap top element. Decide it if a heap, by building heap method, adjust to a heap.</p>
<p>As show below:</p>
<p><img src="/img/Heap-Sort.gif" alt="Heap Sort"></p>
<p><strong>算法：</strong></p>
<p>堆排序算法可以分为两部分。<br>在第一步中，一个堆是建立在数据之外的。堆常常放在一个完整的二叉树布局的数组中。完整的二叉树将二叉树结构映射到数组索引; 每个数组索引代表一个节点; 节点的父节点，左节点子节点或右节点子节点的索引是简单表达式。对于从零开始的数组，根节点存储在索引0; 如果i是当前节点的索引，那么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iParent（i）= floor（（i-1）/ 2）其中floor函数将实数映射到最小的前导整数。</span><br><span class="line">iLeftChild（i）= 2 * i + 1</span><br><span class="line">iRightChild（i）= 2 * i + 2</span><br></pre></td></tr></table></figure></p>
<p>在第二步中，通过反复从堆（堆的根）中删除最大的元素，并将其插入到数组中，创建一个有序的数组。每次移除堆后都会更新堆以维护堆属性。一旦所有对象都从堆中移除，结果是一个有序的数组。<br>因此需要解决两个问题：<br>（1） 如何建堆？<br>（2） 如何调整剩余（n-1）个元素使其成为一个新堆？</p>
<p>建堆的方法：<br>n个结点的完全二叉树，最后一个结点是第n / 2个个结点的子树，筛选从n / 2个结点开始，依次向前对各结点为根对子树进行筛选，使之成为堆，直到根结点。</p>
<p>调整构建新堆的办法：<br>输出堆的顶部元素，将堆底部元素移动到原始堆顶部元素的位置。判断是否为堆，通过生成堆方法，调整为堆。</p>
<p>如上图所示。</p>
<p><strong>Heap sort code in C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void swap(int* a, int* b) &#123;</span><br><span class="line">    int temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void max_heapify(int arr[], int start, int end) &#123;</span><br><span class="line">    //set up parent and sub-node index</span><br><span class="line">    int dad = start;</span><br><span class="line">    int son = dad * 2 + 1;</span><br><span class="line">    while (son &lt;= end) &#123;                //compared if sub-node index in range</span><br><span class="line">        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) //compare two nodes, select the significant</span><br><span class="line">            son++;</span><br><span class="line">        if (arr[dad] &gt; arr[son]) //adjustment finished when parent node larger than sub-node, then jump out of the function</span><br><span class="line">            return;</span><br><span class="line">        else &#123;              //else exchange parent node and sub-node, then sub-node compared with sub-sub-node</span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * 2 + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void heap_sort(int arr[], int len) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    //init, i start with the last parent node</span><br><span class="line">    for (i = len / 2 - 1; i &gt;= 0; i--)</span><br><span class="line">        max_heapify(arr, i, len - 1);</span><br><span class="line">        //swap the first element with the previous one, and then adjust it until the end</span><br><span class="line">    for (i = len - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(&amp;arr[0], &amp;arr[i]);</span><br><span class="line">        max_heapify(arr, 0, i - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h2><p><strong>Overview:</strong></p>
<p>Bubble sort has worst-case and average complexity both О(n^2), where n is the number of items being sorted. Therefore, bubble sort is not a practical sorting algorithm when n is large. The only significant advantage that bubble sort has over most other implementations, even quicksort, but not insertion sort, is that the ability to detect that the list is sorted efficiently is built into the algorithm. When the list is already sorted (best-case), the complexity of bubble sort is only O(n). However, not only does insertion sort have this mechanism too, but it also performs better on a list that is substantially sorted (having a small number of inversions).<br>Bubble sort algorithm operates as follows:</p>
<ol>
<li>Compare adjacent elements. If the first one is bigger than the second, swap them both.</li>
<li>For each pair of adjacent elements for the same operation, from the beginning of the first pair to the end of the last pair. After this step is done, the final element will be the largest number.</li>
<li>Repeat the above steps for all the elements except the last one.</li>
<li>Repeat the above steps for fewer and fewer elements each time, until no pair of numbers needs to be compared.</li>
</ol>
<p><strong>概述：</strong></p>
<p>冒泡排序的最坏情况和平均情况的时间复杂度都是O(n^2)，其中n是排序项目的数量。因此，当n很大的时候，冒泡排序并不是一个很实用的排序算法。但冒泡排序对大多数其他实现（甚至是快速排序，而不是插入排序）的唯一显著优势是能够检测列表是否被高效排序。当列表已经排序（最好的情况），冒泡排序的时间复杂度只有O(n)。但是，插入排序不仅有这种机制，而且在基本排序的列表上（反转次数很少）也会更好。<br>冒泡排序算法的运作如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p><img src="/img/Bubble-Sort.gif" alt="Bubble Sort"></p>
<p><strong>Bubble sort code in C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void bubble_sort(int arr[], int len) &#123;</span><br><span class="line">    int i, j, temp;</span><br><span class="line">    for (i = 0; i &lt; len - 1; i++)</span><br><span class="line">        for (j = 0; j &lt; len - 1 - i; j++)</span><br><span class="line">            if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p><strong>Overview:</strong><br>Quick sort sometimes called partition-exchange sort, Developed by Tony Hoare.  on average, the algorithm takes O(nlogn) comparisons to sort n items. In the worst case, it makes O(n^2) comparisons, though this behavior is rare. In fact qucik sort is usually faster than other O(nlogn) algorithm because its inner loop can be efficiently implemented on most architectures.</p>
<p><strong>概述：</strong><br>快速排序，又称划分交换排序，最早由东尼·霍尔提出。在平均状况下，排序n个项目要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p>
<p><strong>Algorithm:</strong></p>
<p>Quicksort is a divide and conquer algorithm. Quicksort first divides a large array into two smaller sub-arrays: the low elements and the high elements. Quicksort can then recursively sort the sub-arrays.<br>The steps are:</p>
<ol>
<li>Pick an element, called a pivot, from the array.</li>
<li>Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.</li>
<li>Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.<br>The base case of the recursion is arrays of size zero or one, which are in order by definition, so they never need to be sorted.</li>
</ol>
<p><strong>算法：</strong></p>
<p>快速排序使用分治法策略来把一个序列分为两个子序列，然后递归的对子序列进行排序。<br>步骤为：</p>
<ol>
<li>从数列中挑出一个元素，称为”基准”。</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作。</li>
<li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。<br>递归到最底部时，数列的大小是零或一，也就是已经排序好了。</li>
</ol>
<p><strong>Quick sort code in C:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void swap(int *x, int *y) &#123;</span><br><span class="line">    int t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort_recursive(int arr[], int start, int end) &#123;</span><br><span class="line">    if (start &gt;= end)</span><br><span class="line">        return;</span><br><span class="line">    int mid = arr[end];</span><br><span class="line">    int left = start, right = end - 1;</span><br><span class="line">    while (left &lt; right) &#123;</span><br><span class="line">        while (arr[left] &lt; mid &amp;&amp; left &lt; right)</span><br><span class="line">            left++;</span><br><span class="line">        while (arr[right] &gt;= mid &amp;&amp; left &lt; right)</span><br><span class="line">            right--;</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[left] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[left], &amp;arr[end]);</span><br><span class="line">    else</span><br><span class="line">        left++;</span><br><span class="line">    if (left)</span><br><span class="line">        quick_sort_recursive(arr, start, left - 1);</span><br><span class="line">    quick_sort_recursive(arr, left + 1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort(int arr[], int len) &#123;</span><br><span class="line">    quick_sort_recursive(arr, 0, len - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h2><p><strong>Overview:</strong></p>
<p>Merge sort  is an effective sort algorithm created on merge operation with O(nlogn) time performance and it was invented by John von Neumann in 1945. Merge sort is a typical application of divide and conquer  and the layers of sub-recursive can be carried out simultaneously.</p>
<p><strong>概述：</strong></p>
<p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p><strong>Algorithm:</strong></p>
<p>Conceptually, a merge sort works as follows:</p>
<ol>
<li>Divide the unsorted list into n sublists, each containing 1 element (a list of 1 element is considered sorted).</li>
<li>Repeatedly merge sublists to produce new sorted sublists until there is only 1 sublist remaining. This will be the sorted list.</li>
</ol>
<p><strong>算法：</strong></p>
<p>从概念上讲，合并排序的工作原理如下：</p>
<ol>
<li>将未排序的列表分成n个子列表，每个子列表包含1个元素（1个元素的列表被认为是排序的）。</li>
<li>反复合并子列表以产生新的已排序子列表，直到只剩下1个子列表。这将是排序的列表。</li>
</ol>
<p><img src="/img/Merge-Sort.gif" alt="Merge Sort"></p>
<p><strong>Top-down Merge sort Implementation code in C-like Code:</strong></p>
<p>Example using indices for top down merge sort algorithm that recursively splits the list (called runs in this example) into sublists until sublist size is 1, then merges those sublists to produce a sorted list. The copy back step is avoided with alternating the direction of the merge with each level of recursion.</p>
<p>示例使用索引自顶向下归并排序算法递归地将列表（本例中称为运行）分割成子列表，直到子列表大小为1，然后合并这些子列表以生成排序列表。避免了复制后退步骤，将合并的方向与递归的每个级别交替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Array A[] has the items to sort; array B[] is a work array.</span><br><span class="line">TopDownMergeSort(A[], B[], n) &#123;</span><br><span class="line">    CopyArray(A, 0, n, B);           // duplicate array A[] into B[]</span><br><span class="line">    TopDownSplitMerge(B, 0, n, A);   // sort data from B[] into A[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Sort the given run of array A[] using array B[] as a source.</span><br><span class="line">// iBegin is inclusive; iEnd is exclusive (A[iEnd] is not in the set).</span><br><span class="line">TopDownSplitMerge(B[], iBegin, iEnd, A[]) &#123;</span><br><span class="line">    if(iEnd - iBegin &lt; 2)                       // if run size == 1</span><br><span class="line">        return;                                 //   consider it sorted</span><br><span class="line">    // split the run longer than 1 item into halves</span><br><span class="line">    iMiddle = (iEnd + iBegin) / 2;              // iMiddle = mid point</span><br><span class="line">    // recursively sort both runs from array A[] into B[]</span><br><span class="line">    TopDownSplitMerge(A, iBegin,  iMiddle, B);  // sort the left  run</span><br><span class="line">    TopDownSplitMerge(A, iMiddle,    iEnd, B);  // sort the right run</span><br><span class="line">    // merge the resulting runs from array B[] into A[]</span><br><span class="line">    TopDownMerge(B, iBegin, iMiddle, iEnd, A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Left source half is A[ iBegin:iMiddle-1].</span><br><span class="line">// Right source half is A[iMiddle:iEnd-1   ].</span><br><span class="line">// Result is            B[ iBegin:iEnd-1   ].</span><br><span class="line">TopDownMerge(A[], iBegin, iMiddle, iEnd, B[]) &#123;</span><br><span class="line">    i = iBegin, j = iMiddle;</span><br><span class="line"></span><br><span class="line">    // While there are elements in the left or right runs...</span><br><span class="line">    for (k = iBegin; k &lt; iEnd; k++) &#123;</span><br><span class="line">    // If left run head exists and is &lt;= existing right run head.</span><br><span class="line">        if (i &lt; iMiddle &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) &#123;</span><br><span class="line">            B[k] = A[i];</span><br><span class="line">            i = i + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            B[k] = A[j];</span><br><span class="line">            j = j + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CopyArray(A[], iBegin, iEnd, B[]) &#123;</span><br><span class="line">    for(k = iBegin; k &lt; iEnd; k++)</span><br><span class="line">        B[k] = A[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Bottom-up Merge sort Implementation code in C-like Code:</strong></p>
<p>Example using indices for bottom up merge sort algorithm which treats the list as an array of n sublists (called runs in this example) of size 1, and iteratively merges sub-lists back and forth between two buffers.</p>
<p>示例使用索引进行自底向上合并排序算法，该算法将列表视为大小为1 的n个子列表（在此示例中称为运行）的数组，并在两个缓冲区之间迭代地合并子列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// array A[] has the items to sort; array B[] is a work array</span><br><span class="line">void BottomUpMergeSort(A[], B[], n) &#123;</span><br><span class="line">    // Each 1-element run in A is already &quot;sorted&quot;.</span><br><span class="line">    // Make successively longer sorted runs of length 2, 4, 8, 16... until whole array is sorted.</span><br><span class="line">    for (width = 1; width &lt; n; width = 2 * width) &#123;</span><br><span class="line">        // Array A is full of runs of length width.</span><br><span class="line">        for (i = 0; i &lt; n; i = i + 2 * width) &#123;</span><br><span class="line">            // Merge two runs: A[i:i+width-1] and A[i+width:i+2*width-1] to B[]</span><br><span class="line">            // or copy A[i:n-1] to B[] ( if(i+width &gt;= n) )</span><br><span class="line">            BottomUpMerge(A, i, min(i+width, n), min(i+2*width, n), B);</span><br><span class="line">        &#125;</span><br><span class="line">        // Now work array B is full of runs of length 2*width.</span><br><span class="line">        // Copy array B to array A for next iteration.</span><br><span class="line">        // A more efficient implementation would swap the roles of A and B.</span><br><span class="line">        CopyArray(B, A, n);</span><br><span class="line">        // Now array A is full of runs of length 2*width.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Left run is A[iLeft:iRight-1].</span><br><span class="line">// Right run is A[iRight:iEnd-1  ].</span><br><span class="line">void BottomUpMerge(A[], iLeft, iRight, iEnd, B[]) &#123;</span><br><span class="line">    i = iLeft, j = iRight;</span><br><span class="line">    // While there are elements in the left or right runs...</span><br><span class="line">    for (k = iLeft; k &lt; iEnd; k++) &#123;</span><br><span class="line">    // If left run head exists and is &lt;= existing right run head.</span><br><span class="line">        if (i &lt; iRight &amp;&amp; (j &gt;= iEnd || A[i] &lt;= A[j])) &#123;</span><br><span class="line">            B[k] = A[i];</span><br><span class="line">            i = i + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            B[k] = A[j];</span><br><span class="line">            j = j + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CopyArray(B[], A[], n) &#123;</span><br><span class="line">    for(i = 0; i &lt; n; i++)</span><br><span class="line">        A[i] = B[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h2><p>Optimization of some algorithms not write now, can lead to reference answers. This blog only put the first level of knowledge points, aimed at the primary understanding of exploration. Put a summary table below:</p>
<p>对一些算法的优化暂时不写，可以引经据典找到答案。 这篇博客只面向初学者，旨在对知识的理解和进行探索。 下面列出一个表：</p>
<p><img src="/img/Summarize-1.png" alt="Summarize 1"><br><img src="/img/Summarize-2.png" alt="Summarize 2"></p>
<hr>
<p><strong>Stay hungry. Stay foolish.</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/13/The-Differences-between-TCP-UDP-HTTP-HTTPS-GET-POST/" rel="next" title="The Differences between TCP&UDP/HTTP&HTTPS/GET&POST">
                <i class="fa fa-chevron-left"></i> The Differences between TCP&UDP/HTTP&HTTPS/GET&POST
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/icon.png"
                alt="Apach3" />
            
              <p class="site-author-name" itemprop="name">Apach3</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry, stay foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Foreword"><span class="nav-number">1.</span> <span class="nav-text">Foreword</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Insertion-Sort"><span class="nav-number">2.</span> <span class="nav-text">Insertion Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell-Sort"><span class="nav-number">3.</span> <span class="nav-text">Shell Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selection-Sort"><span class="nav-number">4.</span> <span class="nav-text">Selection Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Sort"><span class="nav-number">5.</span> <span class="nav-text">Heap Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bubble-Sort"><span class="nav-number">6.</span> <span class="nav-text">Bubble Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">7.</span> <span class="nav-text">Quick Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Merge-Sort"><span class="nav-number">8.</span> <span class="nav-text">Merge Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summarize"><span class="nav-number">9.</span> <span class="nav-text">Summarize</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; Copyright &mdash; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Apach3</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      人次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://apach3q.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://Apach3Q.github.io.git/2017/11/15/Sort-Algorithm-Summary/';
          this.page.identifier = '2017/11/15/Sort-Algorithm-Summary/';
          this.page.title = 'Sort Algorithm Summary';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://apach3q.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  














<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("EBRJOpOjlzmhk7FYicBdM7Gd-gzGzoHsz", "cPNz2og9fFYar8QzkcCWKpYl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
